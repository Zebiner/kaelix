# MemoryStreamer Security Pipeline
# Comprehensive security scanning and vulnerability detection
# Zero-tolerance security enforcement for production deployment

name: Security Pipeline

on:
  schedule:
    # Run weekly security scans on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'
  push:
    branches: [main, develop]
    paths:
      - '**/*.rs'
      - '**/Cargo.toml'
      - '**/Cargo.lock'
      - '.github/workflows/security.yml'
  pull_request:
    branches: [main, develop]
    paths:
      - '**/*.rs'
      - '**/Cargo.toml'
      - '**/Cargo.lock'
  workflow_dispatch:
    inputs:
      security_level:
        description: 'Security scan level'
        required: false
        default: 'standard'
        type: choice
        options:
          - standard
          - comprehensive
          - paranoid
      include_fuzz_testing:
        description: 'Include fuzz testing'
        required: false
        default: false
        type: boolean
      force_dependency_update:
        description: 'Force dependency security updates'
        required: false
        default: false
        type: boolean

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  RUST_BACKTRACE: 1
  # Security hardening flags
  RUSTFLAGS: "-D warnings -C target-cpu=native"
  # Audit configuration
  CARGO_AUDIT_OPTIONS: "--deny warnings --deny unmaintained --deny unsound --deny yanked"

defaults:
  run:
    shell: bash

jobs:
  # =============================================================================
  # SECURITY ENVIRONMENT SETUP
  # Configure security scanning tools and environment
  # =============================================================================
  
  security-setup:
    name: Security Environment Setup
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      scan-level: ${{ steps.config.outputs.scan-level }}
      tools-matrix: ${{ steps.config.outputs.tools-matrix }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy, llvm-tools-preview
    
    - name: Configure security scan level
      id: config
      run: |
        SCAN_LEVEL="${{ github.event.inputs.security_level || 'standard' }}"
        echo "scan-level=$SCAN_LEVEL" >> $GITHUB_OUTPUT
        
        # Configure tools matrix based on scan level
        case $SCAN_LEVEL in
          "standard")
            TOOLS='["audit", "deny", "geiger", "clippy-security"]'
            ;;
          "comprehensive")
            TOOLS='["audit", "deny", "geiger", "clippy-security", "semver", "outdated"]'
            ;;
          "paranoid")
            TOOLS='["audit", "deny", "geiger", "clippy-security", "semver", "outdated", "fuzz", "miri"]'
            ;;
        esac
        
        echo "tools-matrix=$TOOLS" >> $GITHUB_OUTPUT
        echo "Security scan level: $SCAN_LEVEL"
        echo "Tools to run: $TOOLS"
    
    - name: Install security scanning tools
      run: |
        # Core security tools
        cargo install --locked \
          cargo-audit \
          cargo-deny \
          cargo-geiger \
          cargo-semver-checks \
          cargo-outdated \
          || echo "Some tools failed to install"
        
        # Advanced tools for comprehensive/paranoid scans
        if [[ "${{ steps.config.outputs.scan-level }}" != "standard" ]]; then
          cargo install --locked \
            cargo-fuzz \
            cargo-miri \
            || echo "Advanced tools failed to install"
        fi
    
    - name: Verify tool installation
      run: |
        echo "Installed security tools:"
        cargo audit --version || echo "cargo-audit not available"
        cargo deny --version || echo "cargo-deny not available" 
        cargo geiger --version || echo "cargo-geiger not available"
        
        if [[ "${{ steps.config.outputs.scan-level }}" != "standard" ]]; then
          cargo semver-checks --version || echo "cargo-semver-checks not available"
          cargo outdated --version || echo "cargo-outdated not available"
        fi

  # =============================================================================
  # DEPENDENCY VULNERABILITY SCANNING
  # Comprehensive dependency security analysis
  # =============================================================================
  
  dependency-security:
    name: Dependency Security Scan
    runs-on: ubuntu-latest
    needs: security-setup
    timeout-minutes: 20
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Rust toolchain
      uses: dtolnay/rust-toolchain@stable
    
    - name: Setup Rust cache
      uses: Swatinem/rust-cache@v2
      with:
        key: security-deps-${{ runner.os }}
        cache-on-failure: true
    
    - name: Install cargo-audit
      run: cargo install --locked cargo-audit
    
    - name: Run dependency vulnerability scan
      run: |
        echo "Running dependency vulnerability scan..."
        cargo audit ${{ env.CARGO_AUDIT_OPTIONS }} --format json > security-audit.json
        
        # Also generate human-readable report
        cargo audit ${{ env.CARGO_AUDIT_OPTIONS }} > security-audit.txt
        
        echo "Vulnerability scan completed"
        cat security-audit.txt
    
    - name: Analyze vulnerability results
      run: |
        # Check for critical vulnerabilities
        CRITICAL_VULNS=$(jq '.vulnerabilities | map(select(.severity == "critical")) | length' security-audit.json)
        HIGH_VULNS=$(jq '.vulnerabilities | map(select(.severity == "high")) | length' security-audit.json)
        MEDIUM_VULNS=$(jq '.vulnerabilities | map(select(.severity == "medium")) | length' security-audit.json)
        
        echo "Vulnerability summary:"
        echo "- Critical: $CRITICAL_VULNS"
        echo "- High: $HIGH_VULNS"  
        echo "- Medium: $MEDIUM_VULNS"
        
        # Fail on critical or high vulnerabilities
        if [[ "$CRITICAL_VULNS" -gt 0 ]]; then
          echo "::error::Critical vulnerabilities found - deployment blocked"
          exit 1
        fi
        
        if [[ "$HIGH_VULNS" -gt 0 ]]; then
          echo "::error::High severity vulnerabilities found - deployment blocked"
          exit 1
        fi
        
        if [[ "$MEDIUM_VULNS" -gt 0 ]]; then
          echo "::warning::Medium severity vulnerabilities found - review required"
        fi
    
    - name: Check for unmaintained dependencies
      run: |
        # Check for unmaintained crates
        if cargo audit --format json | jq -r '.vulnerabilities[] | select(.informational == "unmaintained") | .package.name' | head -5; then
          echo "::warning::Some dependencies are unmaintained - consider alternatives"
        fi
    
    - name: Upload vulnerability results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: dependency-security-scan
        path: |
          security-audit.json
          security-audit.txt
        retention-days: 90

  # =============================================================================
  # SUPPLY CHAIN SECURITY
  # License compliance and dependency policy enforcement
  # =============================================================================
  
  supply-chain-security:
    name: Supply Chain Security
    runs-on: ubuntu-latest
    needs: security-setup
    timeout-minutes: 15
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Rust toolchain
      uses: dtolnay/rust-toolchain@stable
    
    - name: Setup Rust cache
      uses: Swatinem/rust-cache@v2
      with:
        key: security-supply-chain-${{ runner.os }}
        cache-on-failure: true
    
    - name: Install cargo-deny
      run: cargo install --locked cargo-deny
    
    - name: Create deny configuration
      run: |
        cat << 'EOF' > deny.toml
[licenses]
# Allow only specific licenses
allow = [
    "MIT",
    "Apache-2.0", 
    "Apache-2.0 WITH LLVM-exception",
    "BSD-2-Clause",
    "BSD-3-Clause",
    "ISC",
    "Unicode-DFS-2016"
]
# Deny copyleft licenses
deny = [
    "GPL-2.0",
    "GPL-3.0", 
    "AGPL-1.0",
    "AGPL-3.0",
    "LGPL-2.0",
    "LGPL-2.1",
    "LGPL-3.0"
]
confidence-threshold = 0.8

[bans]
# Deny specific crates
deny = [
    { name = "openssl-sys", reason = "Use rustls instead" },
    { name = "cmake", reason = "Avoid build-time dependencies" }
]
# Deny multiple versions of the same crate
multiple-versions = "deny"
wildcards = "deny"
highlight = "all"

[advisories]
# Advisory database configuration  
db-path = "~/.cargo/advisory-db"
db-urls = ["https://github.com/RustSec/advisory-db"]
vulnerability = "deny"
unmaintained = "warn"
yanked = "deny"
notice = "warn"
ignore = []

[sources]
# Only allow crates.io as source
unknown-registry = "deny"
unknown-git = "deny"
allow-registry = ["https://github.com/rust-lang/crates.io-index"]
allow-git = []
EOF
    
    - name: Run supply chain security check
      run: |
        echo "Running supply chain security analysis..."
        cargo deny check 2>&1 | tee supply-chain-report.txt
    
    - name: License compliance report
      run: |
        echo "Generating license compliance report..."
        cargo deny list --format json > licenses.json
        
        # Generate human-readable license summary
        echo "## License Summary" > license-report.md
        jq -r '.[] | "\(.name) \(.version) - \(.license)"' licenses.json | sort | uniq >> license-report.md
        
        # Check for any non-compliant licenses
        NON_COMPLIANT=$(jq -r '.[] | select(.license | contains("GPL") or contains("AGPL") or contains("LGPL")) | .name' licenses.json | wc -l)
        
        if [[ "$NON_COMPLIANT" -gt 0 ]]; then
          echo "::error::Non-compliant licenses detected"
          jq -r '.[] | select(.license | contains("GPL") or contains("AGPL") or contains("LGPL")) | "\(.name): \(.license)"' licenses.json
          exit 1
        fi
    
    - name: Check for typosquatting
      run: |
        # Basic typosquatting detection for common crates
        echo "Checking for potential typosquatting..."
        
        SUSPICIOUS_PATTERNS=(
          "tokio.*" 
          "serde.*"
          "clap.*"
          "reqwest.*"
        )
        
        for pattern in "${SUSPICIOUS_PATTERNS[@]}"; do
          if jq -r '.[].name' licenses.json | grep -E "$pattern" | grep -v "^$(echo $pattern | sed 's/\.\*$//')$"; then
            echo "::warning::Potential typosquatting detected for pattern: $pattern"
          fi
        done
    
    - name: Upload supply chain results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: supply-chain-security
        path: |
          supply-chain-report.txt
          licenses.json
          license-report.md
          deny.toml
        retention-days: 90

  # =============================================================================
  # UNSAFE CODE ANALYSIS
  # Analyze unsafe code usage and potential security issues
  # =============================================================================
  
  unsafe-code-analysis:
    name: Unsafe Code Analysis
    runs-on: ubuntu-latest
    needs: security-setup
    timeout-minutes: 20
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Rust toolchain
      uses: dtolnay/rust-toolchain@stable
    
    - name: Setup Rust cache
      uses: Swatinem/rust-cache@v2
      with:
        key: security-unsafe-${{ runner.os }}
        cache-on-failure: true
    
    - name: Install cargo-geiger
      run: cargo install --locked cargo-geiger
    
    - name: Run unsafe code analysis
      run: |
        echo "Analyzing unsafe code usage..."
        cargo geiger --all-features --format json > unsafe-analysis.json
        cargo geiger --all-features --format table > unsafe-analysis.txt
        
        echo "Unsafe code analysis completed"
        cat unsafe-analysis.txt
    
    - name: Analyze unsafe usage
      run: |
        # Extract unsafe statistics
        TOTAL_UNSAFE=$(jq -r '.packages[] | .unsafeties.used.functions + .unsafeties.used.expressions + .unsafeties.used.item_impls + .unsafeties.used.item_traits + .unsafeties.used.methods' unsafe-analysis.json | jq -s 'add')
        UNSAFE_PACKAGES=$(jq -r '.packages[] | select(.unsafeties.used.functions + .unsafeties.used.expressions + .unsafeties.used.item_impls + .unsafeties.used.item_traits + .unsafeties.used.methods > 0) | .name' unsafe-analysis.json | wc -l)
        
        echo "Unsafe code summary:"
        echo "- Total unsafe blocks: $TOTAL_UNSAFE"
        echo "- Packages with unsafe code: $UNSAFE_PACKAGES"
        
        # List packages with unsafe code
        echo "Packages using unsafe code:"
        jq -r '.packages[] | select(.unsafeties.used.functions + .unsafeties.used.expressions + .unsafeties.used.item_impls + .unsafeties.used.item_traits + .unsafeties.used.methods > 0) | "\(.name) (\(.unsafeties.used.functions + .unsafeties.used.expressions + .unsafeties.used.item_impls + .unsafeties.used.item_traits + .unsafeties.used.methods) unsafe blocks)"' unsafe-analysis.json
        
        # Warn on high unsafe usage
        if [[ "$TOTAL_UNSAFE" -gt 100 ]]; then
          echo "::warning::High number of unsafe blocks ($TOTAL_UNSAFE) - review for necessity"
        fi
        
        # Error on unsafe code in our packages (if forbidden)
        OUR_UNSAFE=$(jq -r '.packages[] | select(.name | startswith("kaelix")) | .unsafeties.used.functions + .unsafeties.used.expressions + .unsafeties.used.item_impls + .unsafeties.used.item_traits + .unsafeties.used.methods' unsafe-analysis.json | jq -s 'add // 0')
        
        if [[ "$OUR_UNSAFE" -gt 0 ]]; then
          echo "::error::Unsafe code found in MemoryStreamer packages - forbidden by security policy"
          exit 1
        fi
    
    - name: Generate unsafe code report
      run: |
        cat << 'EOF' > unsafe-code-report.md
# Unsafe Code Analysis Report

## Summary
- **Total unsafe blocks**: $(jq -r '.packages[] | .unsafeties.used.functions + .unsafeties.used.expressions + .unsafeties.used.item_impls + .unsafeties.used.item_traits + .unsafeties.used.methods' unsafe-analysis.json | jq -s 'add')
- **Packages with unsafe code**: $(jq -r '.packages[] | select(.unsafeties.used.functions + .unsafeties.used.expressions + .unsafeties.used.item_impls + .unsafeties.used.item_traits + .unsafeties.used.methods > 0) | .name' unsafe-analysis.json | wc -l)

## Packages Using Unsafe Code
EOF
        
        jq -r '.packages[] | select(.unsafeties.used.functions + .unsafeties.used.expressions + .unsafeties.used.item_impls + .unsafeties.used.item_traits + .unsafeties.used.methods > 0) | "- \(.name): \(.unsafeties.used.functions + .unsafeties.used.expressions + .unsafeties.used.item_impls + .unsafeties.used.item_traits + .unsafeties.used.methods) unsafe blocks"' unsafe-analysis.json >> unsafe-code-report.md
        
        echo "Unsafe code report generated"
    
    - name: Upload unsafe code analysis
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: unsafe-code-analysis
        path: |
          unsafe-analysis.json
          unsafe-analysis.txt
          unsafe-code-report.md
        retention-days: 90

  # =============================================================================
  # STATIC ANALYSIS SECURITY TESTING (SAST)
  # Advanced static analysis for security vulnerabilities
  # =============================================================================
  
  static-analysis:
    name: Static Analysis Security Testing
    runs-on: ubuntu-latest
    needs: security-setup
    timeout-minutes: 25
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
    
    - name: Setup Rust cache
      uses: Swatinem/rust-cache@v2
      with:
        key: security-sast-${{ runner.os }}
        cache-on-failure: true
    
    - name: Run security-focused clippy analysis
      run: |
        echo "Running security-focused static analysis..."
        cargo clippy --all-features --all-targets -- \
          -D clippy::suspicious \
          -D clippy::nursery \
          -D clippy::panic_in_result_fn \
          -D clippy::unwrap_used \
          -D clippy::expect_used \
          -D clippy::indexing_slicing \
          -D clippy::integer_arithmetic \
          -D clippy::float_arithmetic \
          -D clippy::as_conversions \
          -D clippy::cast_ptr_alignment \
          -D clippy::fn_to_numeric_cast_with_truncation \
          -D clippy::lossy_float_literal \
          -D clippy::mem_forget \
          -D clippy::mutex_atomic \
          -D clippy::string_slice \
          -D clippy::weak_rng \
          -D clippy::rc_buffer \
          -D clippy::rc_mutex \
          2>&1 | tee sast-report.txt
    
    - name: Check for security anti-patterns
      run: |
        echo "Scanning for security anti-patterns..."
        
        # Create security pattern checker
        cat << 'EOF' > check_security_patterns.py
#!/usr/bin/env python3
import re
import os
import sys
from pathlib import Path

SECURITY_PATTERNS = [
    # Dangerous patterns
    (r'\.unwrap\(\)', 'Unwrap usage - can cause panics'),
    (r'\.expect\(', 'Expect usage - consider proper error handling'),
    (r'unsafe\s*{', 'Unsafe block - requires careful review'),
    (r'std::ptr::', 'Raw pointer usage - potential memory safety issue'),
    (r'std::mem::transmute', 'Memory transmute - dangerous operation'),
    (r'std::slice::from_raw_parts', 'Raw slice creation - potential UB'),
    
    # Crypto/random patterns
    (r'rand::random', 'Consider using cryptographically secure RNG'),
    (r'std::collections::HashMap\s*<.*String', 'Consider using IndexMap for deterministic ordering'),
    
    # Network/serialization patterns
    (r'serde_json::from_str.*\.unwrap', 'JSON parsing with unwrap - handle errors'),
    (r'bincode::deserialize.*\.unwrap', 'Binary deserialization with unwrap'),
    
    # File/IO patterns
    (r'std::fs::read.*\.unwrap', 'File operations with unwrap'),
    (r'std::env::var.*\.unwrap', 'Environment variable access with unwrap'),
    
    # Threading patterns
    (r'std::sync::.*\.lock\(\)\.unwrap', 'Mutex lock with unwrap - can panic'),
    (r'std::thread::spawn.*\.join\(\)\.unwrap', 'Thread join with unwrap'),
]

def scan_file(file_path):
    """Scan a single file for security patterns"""
    issues = []
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        for line_num, line in enumerate(content.splitlines(), 1):
            for pattern, description in SECURITY_PATTERNS:
                if re.search(pattern, line):
                    # Skip test files and comments
                    if 'test' in str(file_path).lower() or line.strip().startswith('//'):
                        continue
                        
                    issues.append({
                        'file': str(file_path),
                        'line': line_num,
                        'pattern': pattern,
                        'description': description,
                        'code': line.strip()
                    })
    except Exception as e:
        print(f"Error scanning {file_path}: {e}")
    
    return issues

def main():
    """Main scanning function"""
    all_issues = []
    
    # Scan all Rust files
    for rust_file in Path('.').rglob('*.rs'):
        if 'target' not in str(rust_file):
            issues = scan_file(rust_file)
            all_issues.extend(issues)
    
    # Report issues
    if all_issues:
        print(f"Found {len(all_issues)} potential security issues:")
        
        critical_count = 0
        warning_count = 0
        
        for issue in all_issues:
            severity = "CRITICAL" if any(word in issue['pattern'] for word in ['unsafe', 'transmute', 'ptr']) else "WARNING"
            
            print(f"{severity}: {issue['file']}:{issue['line']}")
            print(f"  Pattern: {issue['pattern']}")
            print(f"  Description: {issue['description']}")
            print(f"  Code: {issue['code']}")
            print()
            
            if severity == "CRITICAL":
                critical_count += 1
            else:
                warning_count += 1
        
        print(f"Summary: {critical_count} critical, {warning_count} warnings")
        
        # Exit with error if critical issues found
        if critical_count > 10:  # Allow some unsafe usage in dependencies
            print("Too many critical security issues found")
            sys.exit(1)
    else:
        print("No security issues detected")

if __name__ == "__main__":
    main()
EOF
        
        python3 check_security_patterns.py
    
    - name: Check for hardcoded secrets
      run: |
        echo "Scanning for hardcoded secrets..."
        
        # Check for potential secrets (excluding test files)
        if find . -name "*.rs" -not -path "./target/*" -not -path "*/test*" -exec grep -H -n -E "(api_key|password|secret|token|private_key)\s*[:=]\s*['\"][^'\"]{8,}" {} \;; then
          echo "::error::Potential hardcoded secrets found"
          exit 1
        fi
        
        # Check for suspicious patterns
        if find . -name "*.rs" -not -path "./target/*" -not -path "*/test*" -exec grep -H -n -E "(TODO.*security|FIXME.*security|HACK.*security)" {} \;; then
          echo "::warning::Security-related TODO/FIXME comments found"
        fi
        
        # Check for debug prints in release code
        if find . -name "*.rs" -not -path "./target/*" -not -path "*/test*" -exec grep -H -n "println!\|dbg!\|eprintln!" {} \;; then
          echo "::warning::Debug prints found - may leak sensitive information"
        fi
    
    - name: Upload SAST results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: static-analysis-security
        path: |
          sast-report.txt
          check_security_patterns.py
        retention-days: 90

  # =============================================================================
  # FUZZ TESTING
  # Automated fuzz testing for security vulnerabilities
  # =============================================================================
  
  fuzz-testing:
    name: Fuzz Testing
    runs-on: ubuntu-latest
    needs: security-setup
    timeout-minutes: 60
    if: ${{ github.event.inputs.include_fuzz_testing == 'true' || needs.security-setup.outputs.scan-level == 'paranoid' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Rust toolchain
      uses: dtolnay/rust-toolchain@nightly
      with:
        components: rustfmt, clippy
    
    - name: Setup Rust cache
      uses: Swatinem/rust-cache@v2
      with:
        key: security-fuzz-${{ runner.os }}
        cache-on-failure: true
    
    - name: Install fuzz testing tools
      run: |
        cargo install --locked cargo-fuzz
        sudo apt-get install -y libfuzzer-dev
    
    - name: Check for existing fuzz targets
      id: fuzz-check
      run: |
        if [[ -d "fuzz" ]] && [[ -f "fuzz/Cargo.toml" ]]; then
          echo "fuzz-targets-exist=true" >> $GITHUB_OUTPUT
          echo "Existing fuzz targets found"
        else
          echo "fuzz-targets-exist=false" >> $GITHUB_OUTPUT
          echo "No fuzz targets found - creating basic targets"
        fi
    
    - name: Create basic fuzz targets
      if: steps.fuzz-check.outputs.fuzz-targets-exist == 'false'
      run: |
        # Initialize fuzz testing
        cargo fuzz init
        
        # Create basic fuzz targets for common functions
        cat << 'EOF' > fuzz/fuzz_targets/protocol_decode.rs
#![no_main]
use libfuzzer_sys::fuzz_target;
use kaelix_core::protocol::Frame;

fuzz_target!(|data: &[u8]| {
    // Fuzz frame decoding
    if let Ok(_frame) = Frame::decode(data) {
        // Successfully decoded, try to re-encode
        let _ = _frame.encode();
    }
});
EOF
        
        cat << 'EOF' > fuzz/fuzz_targets/message_serialize.rs
#![no_main]
use libfuzzer_sys::fuzz_target;
use kaelix_core::message::Message;

fuzz_target!(|data: &[u8]| {
    // Fuzz message serialization/deserialization
    if let Ok(msg) = bincode::deserialize::<Message>(data) {
        let _ = bincode::serialize(&msg);
    }
});
EOF
    
    - name: Run fuzz testing
      run: |
        mkdir -p fuzz-results
        
        # Run each fuzz target for limited time
        for target in fuzz/fuzz_targets/*.rs; do
          target_name=$(basename "$target" .rs)
          echo "Running fuzz target: $target_name"
          
          # Run for 5 minutes per target
          timeout 300 cargo fuzz run "$target_name" -- -max_total_time=300 \
            2>&1 | tee "fuzz-results/${target_name}.log" || true
          
          # Check for crashes
          if [[ -d "fuzz/artifacts/$target_name" ]] && [[ $(ls "fuzz/artifacts/$target_name" | wc -l) -gt 0 ]]; then
            echo "::error::Fuzz target $target_name found crashes!"
            cp -r "fuzz/artifacts/$target_name" "fuzz-results/${target_name}-artifacts"
          fi
        done
    
    - name: Analyze fuzz results
      run: |
        echo "Fuzz testing summary:"
        
        TOTAL_CRASHES=0
        for log in fuzz-results/*.log; do
          if [[ -f "$log" ]]; then
            CRASHES=$(grep -c "CRASH\|ERROR\|ASAN" "$log" || echo "0")
            echo "$(basename "$log" .log): $CRASHES issues"
            TOTAL_CRASHES=$((TOTAL_CRASHES + CRASHES))
          fi
        done
        
        echo "Total crashes found: $TOTAL_CRASHES"
        
        if [[ "$TOTAL_CRASHES" -gt 0 ]]; then
          echo "::error::Fuzz testing found $TOTAL_CRASHES crashes - security issue detected"
          exit 1
        fi
    
    - name: Upload fuzz results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: fuzz-testing-results
        path: |
          fuzz-results/
          fuzz/artifacts/
        retention-days: 90

  # =============================================================================
  # SECURITY REPORT GENERATION
  # Consolidate security scan results
  # =============================================================================
  
  security-report:
    name: Security Report
    runs-on: ubuntu-latest
    needs: [security-setup, dependency-security, supply-chain-security, unsafe-code-analysis, static-analysis]
    if: always()
    timeout-minutes: 10
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download security artifacts
      uses: actions/download-artifact@v4
      with:
        path: security-results/
    
    - name: Generate comprehensive security report
      run: |
        cat << 'EOF' > security-report.md
# MemoryStreamer Security Report

## Scan Summary
- **Date**: $(date -u)
- **Commit**: ${{ github.sha }}
- **Scan Level**: ${{ needs.security-setup.outputs.scan-level }}

## Security Check Results
- **Dependency Scan**: ${{ needs.dependency-security.result }}
- **Supply Chain**: ${{ needs.supply-chain-security.result }}
- **Unsafe Code Analysis**: ${{ needs.unsafe-code-analysis.result }}
- **Static Analysis**: ${{ needs.static-analysis.result }}

## Vulnerability Summary
EOF
        
        # Add dependency vulnerabilities if available
        if [[ -f security-results/dependency-security-scan/security-audit.json ]]; then
          CRITICAL=$(jq '.vulnerabilities | map(select(.severity == "critical")) | length' security-results/dependency-security-scan/security-audit.json)
          HIGH=$(jq '.vulnerabilities | map(select(.severity == "high")) | length' security-results/dependency-security-scan/security-audit.json)
          MEDIUM=$(jq '.vulnerabilities | map(select(.severity == "medium")) | length' security-results/dependency-security-scan/security-audit.json)
          
          echo "### Dependency Vulnerabilities" >> security-report.md
          echo "- Critical: $CRITICAL" >> security-report.md
          echo "- High: $HIGH" >> security-report.md
          echo "- Medium: $MEDIUM" >> security-report.md
          echo "" >> security-report.md
        fi
        
        # Add unsafe code summary if available
        if [[ -f security-results/unsafe-code-analysis/unsafe-analysis.json ]]; then
          TOTAL_UNSAFE=$(jq -r '.packages[] | .unsafeties.used.functions + .unsafeties.used.expressions + .unsafeties.used.item_impls + .unsafeties.used.item_traits + .unsafeties.used.methods' security-results/unsafe-code-analysis/unsafe-analysis.json | jq -s 'add')
          
          echo "### Unsafe Code Usage" >> security-report.md
          echo "- Total unsafe blocks: $TOTAL_UNSAFE" >> security-report.md
          echo "" >> security-report.md
        fi
        
        echo "## Recommendations" >> security-report.md
        echo "- Keep dependencies updated" >> security-report.md
        echo "- Review any unsafe code usage" >> security-report.md
        echo "- Monitor security advisories" >> security-report.md
        echo "- Regular security scans" >> security-report.md
        
        echo "Security report generated successfully"
    
    - name: Check overall security status
      run: |
        echo "Security pipeline status:"
        echo "- Dependency security: ${{ needs.dependency-security.result }}"
        echo "- Supply chain: ${{ needs.supply-chain-security.result }}"
        echo "- Unsafe code analysis: ${{ needs.unsafe-code-analysis.result }}"
        echo "- Static analysis: ${{ needs.static-analysis.result }}"
        
        # Fail if any critical security check failed
        if [[ "${{ needs.dependency-security.result }}" == "failure" ]]; then
          echo "::error::Dependency security scan failed"
          exit 1
        fi
        
        if [[ "${{ needs.supply-chain-security.result }}" == "failure" ]]; then
          echo "::error::Supply chain security check failed"
          exit 1
        fi
        
        if [[ "${{ needs.unsafe-code-analysis.result }}" == "failure" ]]; then
          echo "::error::Unsafe code analysis failed"
          exit 1
        fi
        
        if [[ "${{ needs.static-analysis.result }}" == "failure" ]]; then
          echo "::error::Static analysis security testing failed"
          exit 1
        fi
        
        echo "âœ… All security checks passed!"
    
    - name: Upload security report
      uses: actions/upload-artifact@v4
      with:
        name: security-report
        path: security-report.md
        retention-days: 90

# =============================================================================
# SECURITY PIPELINE CONFIGURATION NOTES
# =============================================================================

# This comprehensive security pipeline provides multi-layered security scanning:
#
# 1. DEPENDENCY SECURITY:
#    - Vulnerability scanning with cargo-audit
#    - Critical/high severity blocking
#    - Unmaintained dependency detection
#    - Advisory database integration
#
# 2. SUPPLY CHAIN SECURITY:
#    - License compliance checking
#    - Dependency policy enforcement
#    - Typosquatting detection
#    - Source verification
#
# 3. UNSAFE CODE ANALYSIS:
#    - Comprehensive unsafe code scanning
#    - Security-focused analysis
#    - Zero-tolerance for project unsafe code
#    - Dependency unsafe usage monitoring
#
# 4. STATIC ANALYSIS SECURITY TESTING:
#    - Security-focused clippy lints
#    - Custom security pattern detection
#    - Hardcoded secret scanning
#    - Anti-pattern identification
#
# 5. FUZZ TESTING:
#    - Automated vulnerability discovery
#    - Protocol and message fuzzing
#    - Crash detection and analysis
#    - Security boundary testing
#
# The pipeline enforces zero-tolerance security standards:
# - No critical or high vulnerabilities
# - Compliant licensing only
# - No unsafe code in project
# - No hardcoded secrets
# - Regular security monitoring